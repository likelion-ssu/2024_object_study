
### 훌룡한 설계란?

 - 합리적인 비용 안에서 변경을 수용할 수 있는 구조를 만드는 것
 - 결합도와 응집도를 합리적인 수준으로 유지하는 것
 - 객체의 상태가 아니라 객체의 행동에 초점을 맞추는 것
- 객체의 **책임**에 초점을 맞추는 것

4가지 다 같은 이야기로 정리하자면 <b><u>책임에 초점을 맞추어 객체의 상태에서 행동으로, 나아가 객체와 객체 사이의 상호작용으로 설계 중심을 이동시키고, 결합도가 낮고 응집도가 높으며 구현을 효과적으로 캡슐화하는 객체들을 창조할 수 있는 기반을 제공하는 것</u></b>이 좋은 설계이다.
___
### 객체 지향 설계의 2가지 방법

1. 데이터 중심의 방법
	1. 구현은 불안정하기에 변하기 쉬움
	2. 상태를 객체 분할의 중심축으로 삼기에 캡슐화의 원칙이 무너짐
	3. 상태 변경은 인터페이스의 변경을 초래하며 인터페이스에 의존하는 모든 객체에게 변경의 영향이 퍼짐
2. 책임 중심의 방법
	1. 객체의 책임은 인터페이스에 속함
	2. 객체는 책임을 드러내는 안정적인 인터페이스 뒤로 책임을 수행하는 데 필요한 상태를 캡슐화

___
### 설계 트레이드오프
	좋은 설계의 특징을 판단할 수 있는 품질 척도 3가지

**캡슐화**
	변경 가능성이 높은 부분을 객체 내부로 숨기는 추상화 기법
	상대적으로 안정적인 인터페이스 뒤로 변경 될 가능성이 높은 구현을 숨기는 것

**응집도**
	모듈에 포함된 내부 요소들이 연관돼 있는 정도
	변경이 발생할 때 모듈 내부에서 발생하는 변경의 정도
	하나의 원인에 의해 변경해야 하는 부분이 다수의 모듈에 분산 돼 있는 경우 응집도가 낮다
	![[Pasted image 20240720012924.png]]
**결합도**
	의존성의 정도를 나타내며 다른 모듈에 대해 얼마나 많은 지식을 갖고 있는 지를 나타내는 척도
	한 모듈이 변경되기 위해서 다른 모듈의 변경을 요구하는 정도
	클래스의 구현이 아닌 인터페이스 의존하도록 코드를 작성해야 낮은 결합도를 얻을 수 있음
	![[Pasted image 20240720013247.png]]

**캡슐화의 정도가 응집도와 결합도에 영향을 미친다.**
	캡슐화를 지키면 모듈 안의 응집도가 높아지고 모듈 사이의 결합도는 높아진다.

___
### 데이터 중심의 영화 예매 시스템

**데이터 중심의 영화 예매 시스템**

![[Pasted image 20240720010412.png]]
```java
public class ReservationAgency {
    public Reservation reserve(Screening screening, Customer customer,
                               int audienceCount) {
        Movie movie = screening.getMovie();

        boolean discountable = false;
        for(DiscountCondition condition : movie.getDiscountConditions()) {
            if (condition.getType() == DiscountConditionType.PERIOD) {
                discountable = screening.getWhenScreened().getDayOfWeek().equals(condition.getDayOfWeek()) &&
                        condition.getStartTime().compareTo(screening.getWhenScreened().toLocalTime()) <= 0 &&
                        condition.getEndTime().compareTo(screening.getWhenScreened().toLocalTime()) >= 0;
            } else {
                discountable = condition.getSequence() == screening.getSequence();
            }

            if (discountable) {
                break;
            }
        }

        Money fee;
        if (discountable) {
            Money discountAmount = Money.ZERO;
            switch(movie.getMovieType()) {
                case AMOUNT_DISCOUNT:
                    discountAmount = movie.getDiscountAmount();
                    break;
                case PERCENT_DISCOUNT:
                    discountAmount = movie.getFee().times(movie.getDiscountPercent());
                    break;
                case NONE_DISCOUNT:
                    discountAmount = Money.ZERO;
                    break;
            }

            fee = movie.getFee().minus(discountAmount).times(audienceCount);
        } else {
            fee = movie.getFee().times(audienceCount);
        }

        return new Reservation(customer, screening, fee, audienceCount);
    }
}
```


**데이터 중심의 설계 문제점 정리**
1. 캡슐화 위반 
2. 높은 결합도
3. 낮은 응집도


 **캡슐화 위반**
```java
public class Movie {
    private Money fee;
    
    public Money getFee() {
        return fee;
    }

    public void setFee(Money fee) {
        this.fee = fee;
    }

}   
```
```setFee```, ```getFee``` 메서드는 ```fee``` 인스턴스 변수가 존재한다는 사실을 퍼블릭 인터페이스에 노골적으로 드러내는 문제가 존재

협력에 관해 고민하지 않으면 캡슐화를 위반하는 과도한 접근자와 수정자를 가지게 되는 경향 존재
객체가 사용될 문맥을 추측할 수 밖에 없는 경우에 발생하는 문제로 이를 **추측에 의한 설계 전략**이라고 부름

** 높은 결합도**
 ```java
public class ReservationAgency {

        Money fee;
        if (discountable) {
			...
            fee = movie.getFee().minus(discountAmount).times(audienceCount);
        } else {
	        fee = movie.getFee().times(audienceCount);
        }
			...
}
```
```fee```가 타입 변경될 시에 ```Money``` 타입의 ```fee``` 변수에 저장을 못한다는 문제 발생
또한 ```getFee``` 메서드를 사용하는 것은 인스턴스 변수 ```fee```의 가시성을 private에서 public으로 변경하는 것과 거의 동일

결합도 측면에서 데이터 중심 설계는 하나의 제어 객체가 다수의 데이터 객체에 강하게 결합된다는 문제 존재
변경 발생 시 다수의 의존성으로 인해 시스템 전체가 흔들리는 문제가 발생

![[Pasted image 20240720015654.png]]

**낮은 응집도**

```ResevationAgency```에서 아래와 같은 수정사항 발생 시에 코드 변경이 발생
- 할인 정책이 추가되는 경우
- 할인 정책별로 할인 요금을 계산하는 방법이 변경될 경우
- 할인 조건이 추가되는 경우
- 할인 조건별로 할인 여부를 판단하는 방법이 변경될 경우
- 예매 요금을 계산하는 방법이 변경될 경우

낮은 응집도가 문제를 일으키는 두 가지 측면의 문제
1. 어떤 코드를 수정한 후에 아무런 상관도 없던 코드에 문제 발생
		```ResevationAgency``` 안에 할인 정책을 선택하는 코드와 할인 조건을 판단하는 코드가 함께 존재하기 때문에 새로운 할인 정책을 추가하는 작업이 할인 조건에도 영향을 미칠 수 있음
2. 하나의 요구사항 변경을 반영하기 위해 동시에 여러 모듈을 수정해야 한다.
		새로운 할인 정책을 추가해야한다고 가정할 시에 ```MovieType```에 새로운 할인 정책을 표현하는 열거형 값을 추가하고 ```ReservationAgency```의 ```reserve``` 메서드의 switch 구문에 새로운 case 절을 추가해하며 새로운 하인 정책에 따라 할인 요금을 계산하기 위해 필요한 데이터도 ```Movie``` 에 추가해야 한다.

> [!단일 책임 원책 (SRP)]
> **클래스는 단 한 가지의 변경 이유만 가져야 한다**
> 
> *원칙에서 "책임"은 "변경의 이유"라는 의미로 사용되며 지금까지 정의한 "책임"과는 다름*

___
### 자율적인 객체를 향해

**캡슐화를 지켜라**
	책임을 객체에게 위임해야 함
	객체 내부의 상태를 변경 시킬 수 있는 로직은 객체 내부에 이루어져야 함
![[Pasted image 20240720023110.png]]
![[Pasted image 20240720023123.png]]
위의 예시에서는 다른 클래스에서 Rectangle 클래스를 수정할 수 있기에 2가지 문제가 발생
1. 코드 중복 발생 확률 높음
		다른 클래스에서도 Rectangle 클래스의 상태를 수정하는 메서드를 선언할 시에 중복 코드가 발생함
2. 변경에 취약함
		Rectangle이 right와 bottom 대신 length와 height를 이용해서 사각형을 표현하도록 수정할 시에 기존 접근자 메서드를 사용하던 모든 코드에 영향을 미침

![[Pasted image 20240720023136.png]]Rectangle 클래스를 수정하는 로직을 캡슐화함으로써 해결 가능

이와 같이 "책임"을 가진 객체로 이동시킴으로써 스스로 자신의 데이터를 책임지는 객체를 만들 수 있음
![[Pasted image 20240720023921.png]]
___
### 여전히 부족한 점
 ```java
public class DiscountCondition {
    private DiscountConditionType type;
    private int sequence;
    private DayOfWeek dayOfWeek;
    private LocalTime startTime;
    private LocalTime endTime;

    public DiscountConditionType getType() {}

    public boolean isDiscountable(DayOfWeek dayOfWeek, LocalTime time) {...}

    public boolean isDiscountable(int sequence) {...}
    
 ```
DiscountConditionType의 속성이 변경될 시에 isDiscountable 메서드의 파라미터를 수정하고 해당 메서드를 사용하는 모든 클라이언트도 함께 수정해야함
<b><u>내부 구현의 변경이 외부로 퍼져나가는 파급효과 발생은 캡슐화가 부족하다는 증거</b></u>

 ```java
public class Movie {
    ....

    public Money calculateAmountDiscountedFee() {...}

    public Money calculatePercentDiscountedFee() {...}

    public Money calculateNoneDiscountedFee() {...}

    public boolean isDiscountable(LocalDateTime whenScreened, int sequence) {
        for(DiscountCondition condition : discountConditions) {
            if (condition.getType() == DiscountConditionType.PERIOD) {
                if (condition.isDiscountable(whenScreened.getDayOfWeek(), whenScreened.toLocalTime())) {
                    return true;
                }
            } else {
                if (condition.isDiscountable(sequence)) {
                    return true;
                }
            }
        }

        return false;
    }
}
 ```
 ```calculateAmountDiscountedFee, calculatePercentDiscountedFee, calculateNoneDiscountedFee``` 로 인하여 ```DiscountCondition```의 내부구조가 드러남으로 인해 캡슐화가 제대로 이루어지지 않음

또한```DiscountCondition```의 변경이 Movie에 영향을 미치므로 결합성이 낮음
- ```DiscountCondition```의 기간 할인 조건의 명칭이 ```PERIOD```에서 다른 값으로 변경된다면 ```Movie```를 수정해야 함
- DiscountCondition의 종류가 추가되거나 삭제된다면 Movie 내부의 if else 구조가 바뀜
- 각 ```DiscountCondition``` 만족 여부를 판단하는 데 필요 정보가 변경 시에 ```Movie```의 ```isDiscountable``` 메서드로 전달된 파라미터를 변경해야 함
 ```java
public class Screening {
    public Money calculateFee(int audienceCount) {
        switch (movie.getMovieType()) {
            case AMOUNT_DISCOUNT:
                if (movie.isDiscountable(whenScreened, sequence)) {
                    return movie.calculateAmountDiscountedFee().times(audienceCount);
                }
                break;
            case PERCENT_DISCOUNT:
                if (movie.isDiscountable(whenScreened, sequence)) {
                    return movie.calculatePercentDiscountedFee().times(audienceCount);
                }
            case NONE_DISCOUNT:
                movie.calculateNoneDiscountedFee().times(audienceCount);
        }

        return movie.calculateNoneDiscountedFee().times(audienceCount);
    }
}
 ```
 ```movie.isDiscountable(whenScreened, sequence)```에서 볼 수 있듯이 할인 조건의 종류를 변경하기 위해서는 ```DiscountCondition, Movie, Screening```을 수정해야 함
 응집도가 낮은 이유는 ```DiscountCondition```과 ```Movie``` 내부 구현이 인터페이스 상에 노출되어 있고 ```Screening```은 이에 의존하고 있기 때문
 ```DiscountCondition```과 ```Movie``` 위치해야하는 로직이 ```Screening```에 나와있는 것
 ___

### 데이터 중심 설계의 문제점

- **본질적으로 너무 이른 시기에 데이터에 관해 결정하도록 강요**
		객체의 행동보다는 상태에 초점을 맞춘다
		
- **협력이라는 문맥을 고려하지 않고 객체를 고립시킨 채 오퍼레이션을 결정**
		올바른 객체지향 설계는 객체의 내부가 아니라 외부에 맞춰져 있어야 한다


