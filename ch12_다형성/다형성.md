<p style="text-align:end">
	2024-08-21 15:56 | 오브젝트 | 박수영
</p>

# 🔥학습 목표🔥

1. 상속이 다형성의 기반이 되는 타입 계층 구조화를 위해 사용되어야 함을 알 수 있다.
2. 다양한 형태의 다형성 중에서 ==**서브타입 다형성**==에 대해 알 수 있다.
3. 객체지향 시스템이 런타임에 메시지를 처리할 적절한 메서드를 찾기 위해 사용하는 ==**동적 메서드 탐색 기법**==에 관해 알 수 있다.

# 다형성 🎭
---

> 하나의 추상 인터페이스에 대해 코드를 작성하고 이 추상 인터페이스에 대해 ==서로 다른 구현을 연결==할 수 있는 능력

> ==여러 타입을 대상으로 동작==할 수 있는 코드를 작성할 수 있는 방법

## 다형성의 분류

![[그림12.1.png]]

+ **유니버셜(Universal)**
	타입이 달라도 같은 코드를 수행
	
	1. **[[#1️⃣ 오버로딩(Overloading) 다형성|오버로딩 다형성]]**
		하나의 클래스 안에 동일한 이름의 메서드를 사용하는 방식
	
	2. **[[#2️⃣ 강제(Coercion) 다형성|강제 다형성]]**
		타입 변환을 이용해 동일한 연산자를 다양한 타입에 사용하는 방식

+ **임시(Ad Hoc)**
	타입이 다르면 다른 버전의 코드를 수행
	
	3. **[[#3️⃣ 매개변수(Parametric) 다형성|매개변수 다형성]]**
		클래스의 인스턴스 변수 or 메서드의 매개변수 타입을 사용 시점에 구체적인 타입으로 지정하는 방식
	
	4. **[[#4️⃣ 포함(Inclusion) 다형성|포함 다형성 ⭐⭐]]**
		메시지가 동일하더라도 수신한 객체의 타입에 따라 실제 수행되는 행동이 달라지는 능력

### 1️⃣ 오버로딩(Overloading) 다형성

하나의 클래스 안에 **동일한 이름의 메서드**를 사용하는 방식

+ `public Money plus(Money amount) { ... }`
+ `public Money plus(BigDecimal amount) { ... }`
+ `public Money plus(long amount) { ... }`

유사한 작업을 수행하는 메서드의 이름을 통일 ⇒ 기억해야 하는 이름의 수 🔽

### 2️⃣ 강제(Coercion) 다형성

타입 변환을 이용해 **동일한 연산자를 다양한 타입에 사용**하는 방식

+ 언어가 지원하는 자동 타입 변환
	+ 덧셈 연산: `1 + 1 == 2`
	+ 연결 연산: `1 + "1" == "11"`

+ 사용자가 직접 구현한 타입 변환

### 3️⃣ 매개변수(Parametric) 다형성

클래스의 인스턴스 변수 or 메서드의 매개변수 타입을 임의의 타입으로 선언 
→ **사용 시점에 구체적인 타입으로 지정**하는 방식

+ ==클래스의 인스턴스 변수== - 제네릭 프로그래밍
	+ `public interface List<E> extends Collection<E> { ... }`
	+ 컬렉션의 보관할 요소의 타입을 임의의 타입 E로 지정
	  → 실제 인스턴스 생성 시점에 E를 구체적인 타입으로 지정

+ ==메서드의 매개변수 타입==
	+ `equals` 메서드의 매개변수를 `Object` 타입으로 지정
	  → 비교 시점에 구체적인 타입으로 타입 변환

	```java
	@Override
	public boolean equals(Object obj) {
		if (this == obj) return true;
		if (obj == null && !(obj instanceof Money)) return false;
		Money other = (Money) obj;
		...
	}
	```

### 4️⃣ 포함(Inclusion) 다형성

**메시지가 동일하더라도 수신한 객체의 타입에 따라 실제 수행되는 행동이 달라지는 능력**

+ 서브타입(Subtype) 다형성이라고도 부름

```java
public class Movie {
	private DiscountPolicy discountPolicy;

	public Money calculateMovieFee(Screening screening) {
		// 포함(서브타입) 다형성
		return fee.minus(discountPolicy.calculateDiscountAmount(screening));
	}
}
```

#### 포함 다형성의 전제 조건, 서브타입

+ 자식 클래스에서 부모 클래스의 메서드를 오버라이딩
  ⇒ 클라이언트는 부모 클래스만 참조

+ 객체지향 시스템은 클래스들을 계층으로 쌓아 올린 후, 메시지를 처리할 적절한 메서드를 해당 계층 안에서 탐색

+ 서브 타입 계층을 구축하는 주요 방식은 상속이지만, 그 외에도 다양한 방법이 존재

# 상속 메커니즘의 이해 ⚙️
---

**상속의 목적**
+ 코드 재사용 ❌
+ ==타입 계층 구축== ⭕

상속의 메커니즘을 이해하기 위해서는 다음 개념을 알아야 한다.

+ 업캐스팅
+ 동적 메서드 탐색
+ 동적 바인딩
+ self 참조
+ super 참조

## 상속의 두 가지 관점

1. **데이터 관점의 상속**
	부모 클래스의 모든 ==데이터==를 자식 클래스의 인스턴스에 포함
2. **행동 관점의 상속**
	부모 클래스에서 정의한 일부 ==메서드==를 자식 클래스에 포함

## 인스턴스 관점에서의 상속 관계

인스턴스 관점에서, 상속 관계를 ==단순화==해서 표현하면 다음과 같다.

실제 객체를 메모리에 생성하는 방식이나 구조는 언어나 실행 환경에 따라 다르다.

### 데이터 관점의 상속

인스턴스 관점에서, 자식 클래스의 인스턴스 안에 부모 클래스의 인스턴스가 포함되는 것으로 생각할 수 있다.

인스턴스를 참조하는 `lecture`는 `GradleLecture`의 인스턴스를 가리키기 때문에, 그 안에 포함된 `Lecture`의 인스턴스에 직접 접근할 수 없다.


![[그림12.3.png]]

### 행동 관점의 상속

+ **객체**: ==서로 다른 상태==를 저장 
  ⇒ 각 인스턴스별로 독립적인 메모리 할당

+ **클래스**: 동일한 클래스의 인스턴스끼리 ==메서드 공유== 가능 
  ⇒ 한 번만 메모리에 로드하고 각 인스턴스별로 클래스를 가리키는 포인터 가짐

![[그림12.5.png]]

+ ==**`class` 포인터**==: 객체가 자신의 클래스의 위치를 가리키는 포인터 ^class-ptr
+ ==**`parent` 포인터**==: 클래스가 자신의 부모 클래스의 위치를 가리키는 포인터 ^parent-ptr

+ 부모 클래스에서 구현한 메서드를 자식 클래스의 인스턴스에서 수행할 수 있는 이유?
	1. 메시지를 수신한 객체는 런타임에 `class` 포인터로, 자신의 클래스에서 적절한 메서드가 존재하는지 확인
	2. 만약 메서드가 존재하지 않으면, 클래스의 `parent` 포인터를 따라 부모 클래스에 적절한 메서드가 존재하는지 검색

![[그림12.6.png]]

# 업캐스팅과 동적 바인딩
---

## 업캐스팅

> [!NOTE] 업캐스팅이란?
> **부모 클래스 타입으로 선언된 변수에 자식 클래스의 인스턴스를 할당하는 것**

+ **대입문**과 **메서드의 파라미터 타입**에 적용 가능

###### 대입문

```java
// IOException < Exception
Exception e = new IOException();
```

###### 메서드 파라미터 타입

```java
...
catch (Exception e) {

	e.getMessage();

	// Throwable 타입 변수에 Exception의 인스턴스 할당
	// Exception < Throwable
	throw new RuntimeException(e);
}
```
```java
public RuntimeException(Throwable cause) {  
    super(cause);  
}
```

### 업캐스팅의 의의

**부모 클래스와 협력하는 클라이언트**는, 다양한 ==**자식 클래스의 인스턴스와도 협력**==하는 것이 가능!!

- 현재 상속 계층에 존재하는 자식 클래스
- 앞으로 추가될지도 모르는 미래의 자식 클래스

```java
...
// 1. Exception의 자식 클래스들을 모두 처리
catch (Exception e) {

	// 2. Throwable의 자식 클래스는 모두 getMessage 메시지 이해 가능
	e.getMessage();
	
	throw new RuntimeException(e);
}
```

1. `catch` 문을 통해 `Exception` 클래스의 자식 클래스들을 예외 처리할 수 있다.
2. `Exception` 클래스는 `Throwable`의 자식이기 때문에, `getMessage` 메시지를 이해할 수 있다.

⇒ `Exception`을 상속하는 모든 예외 클래스 + 커스텀 예외 클래스에 대하여 정상적으로 동작
(코드를 수정하지 않더라도!!)

### 다운캐스팅

+ 자식 클래스 타입의 변수에 부모 클래스의 인스턴스를 할당하는 것
+ 명시적인 타입 캐스팅 필요

```java
@Override
public boolean equals(Object obj) {
	if (this == obj) return true;
	if (obj == null && !(obj instanceof Money)) return false;
	
	// 다운캐스팅
	Money other = (Money) obj;
	...
}
```

## 동적 바인딩

> [!NOTE] 동적 바인딩이란?
> **객체지향 시스템이 컴파일 시점이 아닌 런타임 시점에, 메시지를 처리할 적절한 메서드를 결정하는 것**

```java
...
catch (Exception e) {

	// Exception 클래스에 메시지 전송
	// 런타임에 Throwable 클래스의 getMessage 메서드 실행
	e.getMessage();
	
	throw new RuntimeException(e);
}
```

# 동적 메서드 탐색과 다형성
---

객체지향 언어는 어떤 규칙에 따라 "메시지 전송"과 "메서드 호출"을 바인딩하는 걸까?

1. **메시지를 수신한 객체**
	- 해당 객체를 생성한 클래스에 적합한 메서드가 존재하는지 검사
	- 존재하면 메서드를 실행하고 종료

2. **부모 클래스**
	- 앞선 1번에서 메서드를 찾지 못한 경우, 부모 클래스에서 탐색
	- 적합한 메서드를 찾을 때까지 상속 계층을 따라 올라가며 반복

3. **상속 계층의 최상위 클래스(`Object`)**
	- 최상위 클래스에서도 메서드를 발견 못한 경우, 예외 발생시키며 탐색 중단

항상 **자식 클래스의 메서드**가 부모 클래스의 메서드보다 **먼저 탐색**
⇒ ==**자식 클래스의 메서드가 더 높은 우선순위를 가짐**==

## self 참조(self reference)

> [!NOTE] self 참조란?
>**메시지를 수신한 객체를 가리키는 임시 변수**
>
>- C++, 자바, C#의 `this`
>- 루비, 파이썬의 `self`

동적 메서드 탐색은 [[#^class-ptr|class 포인터]]와 [[#^parent-ptr|parent 포인터]], 그리고 `self` 참조를 조합해서 이루어진다.

![[그림12.9.png]]

1. 시스템은 `self` 참조가 가리키는 메모리로 이동
2. 해당 메모리에 존재하는 `class` 포인터를 따라 이동
3. `GradeLecture` 클래스의 정보에 메시지를 처리할 적절한 메서드가 존재하면, 해당 메서드 실행
4. 존재하지 않는다면, `parent` 포인터를 따라 부모 클래스 `Lecture` 로 이동한 후 탐색 진행
5. 상속 계층을 따라 최상위 클래스(`Object`)에 이를 때까지 탐색 진행
6. 최상위 클래스에서도 찾지 못한 경우 에러 발생시키고 탐색 종료

이와 같이 동적 메서드 탐색은 두 가지 원리로 구성된다.

1. **[[#자동적인 메시지 위임|자동적인 메서드 위임]]**
	자식 클래스는 자신이 이해할 수 없는 메시지를, 자동으로 부모 클래스에게 위임한다.
2. **[[#동적인 문맥|동적인 문맥]]**
	메시지 수신 시, 실제로 실행할 메서드의 결정은 런타임에 이뤄진다.

## 자동적인 메시지 위임

자식 클래스는 자신이 이해할 수 없는 메시지를, 자동으로 부모 클래스에게 위임한다.
또한 적절한 메서드를 찾을 때까지 상속 계층을 따라 부모 클래스로 처리가 위임된다.

상속 계층을 따라 부모 클래스에게 자동으로 위임하므로, **상속 계층을 정의하는 것은 메서드 탐색 경로를 정의하는 것**과 동일하다.

## 동적인 문맥

메시지 수신 시, 실제로 실행할 메서드의 결정은 런타임에 이뤄진다.

`self` 참조는 메시지를 수신한 객체를 가리킴으로써, 메서드를 탐색하는 경로를 결정한다.

- **메서드 탐색의 문맥:**
	`(self 참조가 가리키는 객체의 클래스 → Object 클래스)` 상속 계층

- `self` 참조가 가리키는 객체의 타입을 변경함으로써, 객체가 실행될 문맥을 동적으로 바꿀 수 있다.

### self 전송(self send)

>[!NOTE] self 전송이란?
>**self 참조가 가리키는 자기 자신에게, 메시지를 다시 전송하는 것**
>
>- self 참조가 가리키는 객체에서부터 메시지 탐색을 다시 시작한다.

```java
public class Lecture {
	public String stats() {
		// self 참조가 가리키는 객체에 getEvaluationMethod 메시지 전송
		return String.format("Title: %s, Evaluation Method: %s",
			title, getEvaluationMethod());
	}

	public String getEvaluationMethod() { return "Pass or Fail"; }
}
```
```java
public class GradeLecture extends Lecture {
	@Override
	public String getEvaluationMethod() { return "Grade"; }
}
```

```java
Lecture lecture = new Lecture("오브젝트", ...);
lecture.stats();  // Title: 오브젝트, Evaluation Method: Pass or Fail

lecture = new GradeLecture("오브젝트", ...);
lecture.stats();  // Title: 오브젝트, Evaluation Method: Grade
```

![[그림12.17.png]]

## super 참조 (super reference)

>[!NOTE] super 참조란?
>**부모 클래스의 인스턴스 변수나 메서드에 접근하기 위한 내부 변수**

**`super` 전송**(super send)

- `super` 참조를 통해 메시지를 전송하는 것

```java
public class CustomException extends RuntimeException {  
    @Override  
    public String getMessage() {
	    // super 전송
        return "Message: " + super.getMessage();  
    }  
  
    public CustomException(String message) {  
        super(message);  
    }  
}
```

- 부모 클래스의 "메서드 호출"이 아니기 때문에, **실행하고자 하는 메서드가 반드시 부모 클래스에 없어도 된다.**

- 부모 클래스에서 시작해서 상위의 조상 클래스로 올라가며 적절한 메서드를 탐색한다.

### self 전송 v.s. super 전송

|                  |            `self` 전송             |   `super` 전송   |
| :--------------: | :------------------------------: | :------------: |
| **메서드 탐색 시작 위치** | 메시지를 수신하는 객체의 <br>타입에 따라 동적으로 결정 | 항상 부모 클래스에서 시작 |
| **시작 위치 결정 시점**  |              런타임 시점              |     컴파일 시점     |

# 상속 대 위임
---

>[!NOTE] 위임(delegation)이란?
>**자신이 수신한 메시지를 다른 객체에게 동일하게 전달해서 처리를 요청하는 것**
>- 자신이 정의하지 않거나 처리할 수 없는, 속성 또는 메서드의 탐색 과정을 다른 객체로 이동
>- 항상 현재의 실행 문맥을 가리키는 `self` 참조를 인자로 전달

상속 관계로 연결된 클래스 사이에는 자동적인 메시지 위임이 일어난다.
- 자식 클래스에서 부모 클래스로 `self` 참조를 전달하면서 메시지를 위임

# Hands-on 🤲
---

## 문제 #1 - 서브타입 다형성

아래 `_`에 들어갈 말은 무엇일까요?

서브타입 다형성이란?
- 메시지가 동일하더라도 수신한 객체의 `_`에 따라 실제 수행되는 행동이 달라지는 능력

## 문제 #2 - self 참조

아래 코드에서 `getMessage` 메시지가 전송될 때 생성되는, `self` 참조가 가리키는 객체의 클래스는 무엇일까요?

```java
Exception e = new RuntimeException();
e.getMessage();
```

1. `Object`
2. `Throwable`
3. `Exception`
4. `RuntimeException`


## 문제 #3 - 동적 메서드 탐색 과정

아래 코드의 실행 결과는 무엇일까요?

```java
public class Parent {
	public void hello() {  
	    System.out.println("Hi, I'm parent");  
	}
}
```
```java
public class Child extends Parent {
	public void hello() {  
	    System.out.println("Hi, I'm child");  
	}
}
```
```java
public class Main {  
    public static void main(String[] args) {  
        Parent a = new Child();  
        a.hello();
	}
}
```

1. "Hi, I'm parent"
2. "Hi, I'm child"
3. ""
4. null

## 문제 #4 - self 전송

아래 코드의 실행 결과는 무엇일까요?

```java
public class Parent {
	public void hello() {  
	    System.out.println("Hi, I'm " + name());  
	}

	public String name() { return "parent"; }
}
```
```java
public class Child extends Parent {
	@Override
	public String name() { return "child"; }
}
```
```java
public class Main {  
    public static void main(String[] args) {  
        Parent a = new Parent();  
        a.hello();
	}
}
```

1. "Hi, I'm parent"
2. "Hi, I'm child"
3. ""
4. null